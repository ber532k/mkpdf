debug_log_loop() {
    while true; do
        find /tmp/mkpdf | grep latexmk.log | while read logfile; do
        if [[ "$(cat $logfile | tail -1 | grep 'Latexmk: All targets' | grep 'are up-to-date')" ]]; then
            echo "$logfile"
            echo "    is clean (i. e. latexmk finished ok)"
            echo
        else
            cat $logfile
            echo
            echo -------------------------------
            echo Above is the content of $logfile
            echo -------------------------------
            read -p "Hit Enter to search for further errors" </dev/tty
            echo
            echo
            echo
        fi
        done
        echo
        echo     ______________________
        read -p "Hit Enter to run again" </dev/tty
        echo
        echo
        echo
    done
}


clean_all() {
    if [[ -d /tmp/mkpdf ]]; then
        rm -r /tmp/mkpdf && echo "    Successfully removed all temporary files"
    else
        echo "    No files left to remove"
    fi
}


read_input() {
    # Input:   string (probably $@)
    # Read input and set variables accordingly
    # Help options and -c, -d (standalone) will be executed immediately
    # and cause the rest of the input to be ignored!
    #
    # The following variables will be set:
    #   - template        if specified
    #   - output          if specified
    #   - title           autogenerated from file- or dirname
    #   - fresh_runs      boolean
    #   - debug_info      boolean
    #   - auto_preview    boolean
    #   - [custom]        if set via --set
    #   - mode            file, toc, empty
    #   - ftype           file type: bib, std
    #   - ttype           template type: latex, beamer
    #   - files           input files (file mode only)
    #   - tocdir          initial directory (toc mode only)
    #   - destdir         current working directory
    #   - reldir          relative path to first file / tocdir in toc mode

    # Booleans are usually configurable and must not be unset
    # here; everything else should be
    unset template
    unset output
    unset title
    unset mode
    unset ftype
    unset ttype
    unset files
    unset tocdir


    ################
    # Parse Input
    ################

    while [[ $1 ]]; do
        # Fallback
        if [[ "$1" = "--use-pantable" ]]; then
                pandoc_options+=" --filter=pantable "
	# Continued
        elif [[ $1 = -h ]] || [[ $1 = --help ]]; then
            print_help
            exit 0
        elif [[ $1 = --help-toc ]]; then
            print_help_toc
            exit 0
        elif [[ $1 = --help-config ]]; then
            print_help_config
            exit 0
        elif [[ $1 = --example-toc ]]; then
            print_basic_toc
            exit 0
        elif [[ $1 = -t ]] || [[ $1 = --template ]]; then
            shift
            template=$1
        elif [[ $1 = --template=* ]]; then
            template="$(echo $1 | sed s/--template=//g)"
        elif [[ $1 = -o ]] || [[ $1 = --output ]]; then
            shift
            output=$1
        elif [[ $1 = --output=* ]]; then
            output="$(echo $1 | sed s/--output=//g)"
        elif [[ $1 = -f ]] || [[ $1 = --fresh ]]; then
            fresh_runs=1
        elif [[ $1 = -c ]] || [[ $1 = --clean ]]; then
            clean_all
            exit 0
        elif [[ $1 = -d ]] || [[ $1 = --debug ]]; then
            debug_info=1
        elif [[ $1 = -p ]] || [[ $1 = --preview ]]; then
            auto_preview=1
        elif [[ $1 = --set ]]; then
            shift
            let $1
        else
            [[ $files ]] && files="$files $1" || files="$1"
        fi
        shift
    done


    ################
    # Get mode
    ################

    if ! [[ $files ]]; then
            if ! [[ $debug_info = 1 ]] && [[ -f toc.conf ]]; then
                    mode=toc
                    tocdir="$PWD"
            else
                    mode=empty
            fi
    elif [[ $files = '.' ]]; then
            mode=toc
            tocdir="$PWD"
    elif [[ -d $files ]]; then
            mode=toc
            tocdir="$files"
    else
            mode=file
    fi

    [[ $mode = toc ]] && files="$(read_toc files $tocdir/toc.conf)"


    ################
    # Get title
    ################

    if [[ $mode = toc ]]; then
        if [[ $(echo "$tocdir" | rev | cut -c1) = / ]]; then
            title="$(echo $tocdir | rev | cut -d / -f 2 | rev)"
        else
            title="$(echo "$tocdir" | rev | cut -d / -f 1 | rev)"
        fi
    elif [[ $mode = file ]]; then
        title=$(echo "$files" | cut -d ' ' -f 1 | rev | cut -d / -f 1 | rev | cut -d . -f 1)
    fi

    ! [[ $output ]] && output="$title.pdf"

    ###############
    # Mode empty
    ###############

    if [[ $mode = empty ]]; then
        if [[ $debug_info = 1 ]]; then
            debug_log_loop
        else
            print_help
        fi
        exit 0
    fi


    #################
    # Check file type
    #################

    x=$(echo "$files" | cut -d ' ' -f1 | rev | cut -d '.' -f1 | rev)
    if [[ $x = bib ]] || [[ $x = bibtex ]] || [[ $x = biblatex ]]; then
            ftype=bib
    else
            ftype=std
    fi


    #################
    # Directories
    #################

    if [[ $mode = toc ]]; then
        reldir="$tocdir"
    elif [[ $mode = std ]] && [[ $(echo "$files" | cut -d ' ' -f 1 | grep /) ]]; then
        reldir=$(echo "$files" | cut -d ' ' -f 1 | rev | cut -d / -f 2- | rev)
    else
        reldir="$PWD"
    fi
}


read_toc() {
    # Input:  1:  runmode (files, meta)
    #        2-:  filename (toc.conf or markdown)
    # Output:   string (of files or YAML-metadata)
    #
    # Note:     Make sure tocdir is sed correctly

    [[ $1 = meta ]] && runmode_here=meta
    [[ $1 = files ]] && runmode_here=files
    shift
    [[ $runmode_here = meta ]] && echo ---

    while read line; do
        if [[ $passthrough = 1 ]]; then
            if [[ $line = --- ]] || [[ $line = ... ]]; then
                 unset passthrough
            else
                # This line contains metadata
                [[ $runmode_here = meta ]] && echo $line
            fi
        elif [[ $ignore = 1 ]]; then
            if [[ $line = '-->' ]]; then
                unset ignore
            fi
        else
            if [[ $line = --- ]]; then
                passthrough=1
            elif [[ $line = '<!--' ]]; then
                ignore=1
            elif [[ $line ]]; then
                # The line contains a filename
                [[ $runmode_here = files ]] && echo -n "$line"
            fi
        fi
    done < <(cat "$(echo $@)" | sed s/'<!--.*-->'//g | sed s/'#.*'//g | sed s/'%.*'//g)

    [[ $runmode_here = meta ]] && echo ---
    unset runmode_here
}



parse_bib_titleblock() {
    # Input:  single filename or multiple filenames
    # Output: string (YAML-metadata)

    for f in $@; do
    echo ---

        field=('title' 'author' 'date')
        i=0

        # Rules for grep
        match='^%%%%* *mkpdf *%%%%*$'
        opt=--ignore-case

        if [[ "$(grep --after-context=1 $opt "$match" $f | head -2 | grep '% *---')" ]]; then
            # Treat as yaml-block
            export parse=0
            cat "$f" | while read line; do
                if [[ $parse = 2 ]]; then
                    if [[ "$(echo $line | grep '% *---')" ]] || [[ "$(echo $line | grep '% *\.\.\.')" ]]; then
                        break
                    elif [[ $line ]] && [[ "$(echo $line | grep '^%')" ]]; then
                        echo "$line" | sed 's/^%[ ]//g'
                    fi
                elif [[ $parse = 1 ]] && [[ "$(echo $line | grep '% *---')" ]]; then
                    parse=2
                elif [[ $parse = 0 ]] && [[ "$(echo $line | grep $opt "$match")" ]]; then
                    parse=1
                fi
            done
        else
            # Treat as pandoc-metadata
            grep --after-context=3 $opt "$match" $f |
                head -4 | tail -3 |
                sed 's/^[^%].*//g' |
                sed 's/^% *//g' |
                while read line; do
            [[ $line ]] && echo "${field[i]}: $line"
                    i=$i+1
                done
        fi

    echo ---
    echo
    done
}


get_template() {
    # Will read files and set template= to a path (or exit trying)
    # Will also (re)set template with an absolute path and set ttype

    ######################
    # Check file(s)
    ######################

    # look at toc.conf
    if ! [[ $template ]] && [[ $mode = toc ]]; then
        template=$(read_toc meta "$tocdir/toc.conf" | grep 'template: ' | head -1 | sed 's/template: //g')
    fi

    # look at files
    if ! [[ $template ]] && [[ $mode = file ]]; then
        for f in $files; do
            template="$(read_toc meta $f | grep 'template: ' | sed 's/template: //g')"
            [[ $template ]] && [[ $(echo $f | grep '/') ]] && template=$(echo $f | sed 's,/.*$,/,g')$template

            [[ $template ]] && break
        done
    fi

    # else use default
    ! [[ $template ]] && template="$default_template"


    ######################
    # Fix Template Path
    ######################
    fix_template_path() {
        if ! [[ -f $template ]]; then
            for d in $template_dirs; do
                if [[ -f "$d/$template" ]]; then
                    template="$d/$template"
                    break
                fi
            done
        fi
    }
    fix_template_path

    ######################
    # Check file exists
    ######################

    if ! [[ -f $template ]]; then
        echo "  ERROR: Template $template could not be located!"
        echo "         Using default template instead"
        template=$default_template
        fix_template_path
        if ! [[ -f $template ]]; then
            echo "  FATAL: The default template $default_template"
            echo "         could not be located either!"
            echo "         Please check your configuration and"
            echo "         setup to verify it exists."
            exit 1
        fi
    fi


    ######################
    # Get template type
    ######################

    if [[ $(cat "$template" | grep '\documentclass' | grep '{beamer}') ]]; then
        ttype=beamer
    elif [[ $(echo "$template" | rev | cut -d '.' -f 1 | rev ) = beamer ]]; then
        ttype=beamer
    else
        ttype=latex
    fi

}
